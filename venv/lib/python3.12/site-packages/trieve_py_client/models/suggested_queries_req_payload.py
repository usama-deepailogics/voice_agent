# coding: utf-8

"""
    Trieve API

    Trieve OpenAPI Specification. This document describes all of the operations available through the Trieve API.

    The version of the OpenAPI document: 0.13.0
    Contact: developers@trieve.ai
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from trieve_py_client.models.chunk_filter import ChunkFilter
from trieve_py_client.models.search_method import SearchMethod
from trieve_py_client.models.suggest_type import SuggestType
from typing import Optional, Set
from typing_extensions import Self

class SuggestedQueriesReqPayload(BaseModel):
    """
    SuggestedQueriesReqPayload
    """ # noqa: E501
    context: Optional[StrictStr] = Field(default=None, description="Context is the context of the query. This can be any string under 15 words and 200 characters. The context will be used to generate the suggested queries. Defaults to None.")
    filters: Optional[ChunkFilter] = None
    query: Optional[StrictStr] = Field(default=None, description="The query to base the generated suggested queries off of using RAG. A hybrid search for 10 chunks from your dataset using this query will be performed and the context of the chunks will be used to generate the suggested queries.")
    search_type: Optional[SearchMethod] = None
    suggestion_type: Optional[SuggestType] = None
    suggestions_to_create: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=None, description="The number of suggested queries to create, defaults to 10")
    __properties: ClassVar[List[str]] = ["context", "filters", "query", "search_type", "suggestion_type", "suggestions_to_create"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SuggestedQueriesReqPayload from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of filters
        if self.filters:
            _dict['filters'] = self.filters.to_dict()
        # set to None if context (nullable) is None
        # and model_fields_set contains the field
        if self.context is None and "context" in self.model_fields_set:
            _dict['context'] = None

        # set to None if filters (nullable) is None
        # and model_fields_set contains the field
        if self.filters is None and "filters" in self.model_fields_set:
            _dict['filters'] = None

        # set to None if query (nullable) is None
        # and model_fields_set contains the field
        if self.query is None and "query" in self.model_fields_set:
            _dict['query'] = None

        # set to None if search_type (nullable) is None
        # and model_fields_set contains the field
        if self.search_type is None and "search_type" in self.model_fields_set:
            _dict['search_type'] = None

        # set to None if suggestion_type (nullable) is None
        # and model_fields_set contains the field
        if self.suggestion_type is None and "suggestion_type" in self.model_fields_set:
            _dict['suggestion_type'] = None

        # set to None if suggestions_to_create (nullable) is None
        # and model_fields_set contains the field
        if self.suggestions_to_create is None and "suggestions_to_create" in self.model_fields_set:
            _dict['suggestions_to_create'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SuggestedQueriesReqPayload from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "context": obj.get("context"),
            "filters": ChunkFilter.from_dict(obj["filters"]) if obj.get("filters") is not None else None,
            "query": obj.get("query"),
            "search_type": obj.get("search_type"),
            "suggestion_type": obj.get("suggestion_type"),
            "suggestions_to_create": obj.get("suggestions_to_create")
        })
        return _obj


