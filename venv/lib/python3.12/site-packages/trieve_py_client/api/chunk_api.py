# coding: utf-8

"""
    Trieve API

    Trieve OpenAPI Specification. This document describes all of the operations available through the Trieve API.

    The version of the OpenAPI document: 0.13.0
    Contact: developers@trieve.ai
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from wsgiref import headers
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
import requests
from typing_extensions import Annotated

from pydantic import Field, StrictStr
from typing import Any, Optional
from typing_extensions import Annotated
from trieve_py_client.models.autocomplete_req_payload import AutocompleteReqPayload
from trieve_py_client.models.bulk_delete_chunk_payload import BulkDeleteChunkPayload
from trieve_py_client.models.chunk_html_content_req_payload import (
    ChunkHtmlContentReqPayload,
)
from trieve_py_client.models.chunk_return_types import ChunkReturnTypes
from trieve_py_client.models.count_chunk_query_response_body import (
    CountChunkQueryResponseBody,
)
from trieve_py_client.models.count_chunks_req_payload import CountChunksReqPayload
from trieve_py_client.models.chunk_req_payload import ChunkReqPayload
from trieve_py_client.models.create_chunk_req_payload_enum import (
    CreateChunkReqPayloadEnum,
)
from trieve_py_client.models.generate_off_chunks_req_payload import (
    GenerateOffChunksReqPayload,
)
from trieve_py_client.models.get_chunks_data import GetChunksData
from trieve_py_client.models.get_tracking_chunks_data import GetTrackingChunksData
from trieve_py_client.models.recommend_chunks_request import RecommendChunksRequest
from trieve_py_client.models.recommend_response_types import RecommendResponseTypes
from trieve_py_client.models.return_queued_chunk import ReturnQueuedChunk
from trieve_py_client.models.scroll_chunks_req_payload import ScrollChunksReqPayload
from trieve_py_client.models.scroll_chunks_response_body import ScrollChunksResponseBody
from trieve_py_client.models.search_chunks_req_payload import SearchChunksReqPayload
from trieve_py_client.models.search_response_types import SearchResponseTypes
from trieve_py_client.models.split_html_response import SplitHtmlResponse
from trieve_py_client.models.suggested_queries_req_payload import (
    SuggestedQueriesReqPayload,
)
from trieve_py_client.models.suggested_queries_response import SuggestedQueriesResponse
from trieve_py_client.models.update_chunk_by_tracking_id_data import (
    UpdateChunkByTrackingIdData,
)
from trieve_py_client.models.update_chunk_req_payload import UpdateChunkReqPayload

from trieve_py_client.api_client import ApiClient, RequestSerialized
from trieve_py_client.api_response import ApiResponse
from trieve_py_client.rest import RESTResponseType


class ChunkApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    def autocomplete(
        self,
        tr_dataset: Annotated[
            StrictStr,
            Field(
                description="The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid."
            ),
        ],
        autocomplete_req_payload: Annotated[
            AutocompleteReqPayload,
            Field(
                description="JSON request payload to semantically search for chunks (chunks)"
            ),
        ],
    ) -> SearchResponseTypes:
        """Autocomplete

        This route provides the primary autocomplete functionality for the API. This prioritize prefix matching with semantic or full-text search.

        :param tr_dataset: The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid. (required)
        :type tr_dataset: str
        :param autocomplete_req_payload: JSON request payload to semantically search for chunks (chunks) (required)
        :type autocomplete_req_payload: AutocompleteReqPayload
        """  # noqa: E501

        payload = self.api_client.sanitize_for_serialization(autocomplete_req_payload)
        url = self.api_client.configuration.host + "/api/chunk/autocomplete"
        headers = {
            "TR-Dataset": tr_dataset,
            "Authorization": self.api_client.configuration.api_key["ApiKey"],
            "Content-Type": "application/json",
            "X-API-Version": "V2",
        }

        response = requests.request("POST", url, json=payload, headers=headers)

        return response.json()

    def bulk_delete_chunk(
        self,
        tr_dataset: Annotated[
            StrictStr,
            Field(
                description="The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid."
            ),
        ],
        bulk_delete_chunk_payload: Annotated[
            BulkDeleteChunkPayload,
            Field(
                description="JSON request payload to speicy a filter to bulk delete chunks"
            ),
        ],
    ) -> None:
        """Bulk Delete Chunks

        Delete multiple chunks using a filter. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.

        :param tr_dataset: The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid. (required)
        :type tr_dataset: str
        :param bulk_delete_chunk_payload: JSON request payload to speicy a filter to bulk delete chunks (required)
        :type bulk_delete_chunk_payload: BulkDeleteChunkPayload
        """  # noqa: E501

        payload = self.api_client.sanitize_for_serialization(bulk_delete_chunk_payload)

        url = self.api_client.configuration.host + "/api/chunk"
        headers = {
            "TR-Dataset": tr_dataset,
            "Authorization": self.api_client.configuration.api_key["ApiKey"],
            "Content-Type": "application/json",
            "X-API-Version": "V2",
        }

        response = requests.request("DELETE", url, json=payload, headers=headers)

        return response.json()

    def count_chunks(
        self,
        tr_dataset: Annotated[
            StrictStr,
            Field(
                description="The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid."
            ),
        ],
        count_chunks_req_payload: Annotated[
            CountChunksReqPayload,
            Field(
                description="JSON request payload to count chunks for a search query"
            ),
        ],
    ) -> CountChunkQueryResponseBody:
        """Count chunks above threshold

        This route can be used to determine the number of chunk results that match a search query including score threshold and filters. It may be high latency for large limits. There is a dataset configuration imposed restriction on the maximum limit value (default 10,000) which is used to prevent DDOS attacks. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.

        :param tr_dataset: The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid. (required)
        :type tr_dataset: str
        :param count_chunks_req_payload: JSON request payload to count chunks for a search query (required)
        :type count_chunks_req_payload: CountChunksReqPayload
        """  # noqa: E501

        payload = self.api_client.sanitize_for_serialization(count_chunks_req_payload)

        url = self.api_client.configuration.host + "/api/chunk/count"
        headers = {
            "TR-Dataset": tr_dataset,
            "Authorization": self.api_client.configuration.api_key["ApiKey"],
            "Content-Type": "application/json",
            "X-API-Version": "V2",
        }

        response = requests.request("POST", url, json=payload, headers=headers)

        return response.json()

    def create_chunk(
        self,
        tr_dataset: Annotated[
            StrictStr,
            Field(
                description="The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid."
            ),
        ],
        create_chunk_req_payload_enum: Annotated[
            CreateChunkReqPayloadEnum,
            Field(description="JSON request payload to create a new chunk (chunk)"),
        ],
    ) -> ReturnQueuedChunk:
        """Create or Upsert Chunk or Chunks

        Create new chunk(s). If the chunk has the same tracking_id as an existing chunk, the request will fail. Once a chunk is created, it can be searched for using the search endpoint. If uploading in bulk, the maximum amount of chunks that can be uploaded at once is 120 chunks. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.

        :param tr_dataset: The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid. (required)
        :type tr_dataset: str
        :param create_chunk_req_payload_enum: JSON request payload to create a new chunk (chunk) (required)
        :type create_chunk_req_payload_enum: CreateChunkReqPayloadEnum
        :return: Returns the result object.
        """  # noqa: E501

        payload = self.api_client.sanitize_for_serialization(
            create_chunk_req_payload_enum
        )

        url = self.api_client.configuration.host + "/api/chunk"
        headers = {
            "TR-Dataset": tr_dataset,
            "Authorization": self.api_client.configuration.api_key["ApiKey"],
            "Content-Type": "application/json",
            "X-API-Version": "V2",
        }

        response = requests.request("POST", url, json=payload, headers=headers)

        return response.json()

    @validate_call
    def delete_chunk(
        self,
        tr_dataset: Annotated[
            StrictStr,
            Field(
                description="The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid."
            ),
        ],
        chunk_id: Annotated[
            StrictStr, Field(description="Id of the chunk you want to fetch.")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete Chunk

        Delete a chunk by its id. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.

        :param tr_dataset: The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid. (required)
        :type tr_dataset: str
        :param chunk_id: Id of the chunk you want to fetch. (required)
        :type chunk_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_chunk_serialize(
            tr_dataset=tr_dataset,
            chunk_id=chunk_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "204": None,
            "400": "ErrorResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _delete_chunk_serialize(
        self,
        tr_dataset,
        chunk_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if chunk_id is not None:
            _path_params["chunk_id"] = chunk_id
        # process the query parameters
        # process the header parameters
        if tr_dataset is not None:
            _header_params["TR-Dataset"] = tr_dataset
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["ApiKey"]

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/api/chunk/{chunk_id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def delete_chunk_by_tracking_id(
        self,
        tr_dataset: Annotated[
            StrictStr,
            Field(
                description="The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid."
            ),
        ],
        tracking_id: Annotated[
            StrictStr, Field(description="tracking_id of the chunk you want to delete")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete Chunk By Tracking Id

        Delete a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.

        :param tr_dataset: The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid. (required)
        :type tr_dataset: str
        :param tracking_id: tracking_id of the chunk you want to delete (required)
        :type tracking_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_chunk_by_tracking_id_serialize(
            tr_dataset=tr_dataset,
            tracking_id=tracking_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "204": None,
            "400": "ErrorResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _delete_chunk_by_tracking_id_serialize(
        self,
        tr_dataset,
        tracking_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tracking_id is not None:
            _path_params["tracking_id"] = tracking_id
        # process the query parameters
        # process the header parameters
        if tr_dataset is not None:
            _header_params["TR-Dataset"] = tr_dataset
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["ApiKey"]

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/api/chunk/tracking_id/{tracking_id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def generate_off_chunks(
        self,
        tr_dataset: Annotated[
            StrictStr,
            Field(
                description="The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid."
            ),
        ],
        generate_off_chunks_req_payload: Annotated[
            GenerateOffChunksReqPayload,
            Field(
                description="JSON request payload to perform RAG on some chunks (chunks)"
            ),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """RAG on Specified Chunks

        This endpoint exists as an alternative to the topic+message resource pattern where our Trieve handles chat memory. With this endpoint, the user is responsible for providing the context window and the prompt and the conversation is ephemeral.

        :param tr_dataset: The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid. (required)
        :type tr_dataset: str
        :param generate_off_chunks_req_payload: JSON request payload to perform RAG on some chunks (chunks) (required)
        :type generate_off_chunks_req_payload: GenerateOffChunksReqPayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._generate_off_chunks_serialize(
            tr_dataset=tr_dataset,
            generate_off_chunks_req_payload=generate_off_chunks_req_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "str",
            "400": "ErrorResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _generate_off_chunks_serialize(
        self,
        tr_dataset,
        generate_off_chunks_req_payload,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if tr_dataset is not None:
            _header_params["TR-Dataset"] = tr_dataset
        # process the form parameters
        # process the body parameter
        if generate_off_chunks_req_payload is not None:
            _body_params = generate_off_chunks_req_payload

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["text/plain", "application/json"]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/json"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ["ApiKey"]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/api/chunk/generate",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_chunk_by_id(
        self,
        tr_dataset: Annotated[
            StrictStr,
            Field(
                description="The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid."
            ),
        ],
        chunk_id: Annotated[
            StrictStr, Field(description="Id of the chunk you want to fetch.")
        ],
        x_api_version: Annotated[
            Optional[Any],
            Field(
                description="The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ChunkReturnTypes:
        """Get Chunk By Id

        Get a singular chunk by id.

        :param tr_dataset: The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid. (required)
        :type tr_dataset: str
        :param chunk_id: Id of the chunk you want to fetch. (required)
        :type chunk_id: str
        :param x_api_version: The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
        :type x_api_version: APIVersion
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_chunk_by_id_serialize(
            tr_dataset=tr_dataset,
            chunk_id=chunk_id,
            x_api_version=x_api_version,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ChunkReturnTypes",
            "400": "ErrorResponseBody",
            "404": "ErrorResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _get_chunk_by_id_serialize(
        self,
        tr_dataset,
        chunk_id,
        x_api_version,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if chunk_id is not None:
            _path_params["chunk_id"] = chunk_id
        # process the query parameters
        # process the header parameters
        if tr_dataset is not None:
            _header_params["TR-Dataset"] = tr_dataset
        if x_api_version is not None:
            _header_params["X-API-Version"] = x_api_version
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["ApiKey"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/chunk/{chunk_id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_chunk_by_tracking_id(
        self,
        tr_dataset: Annotated[
            StrictStr,
            Field(
                description="The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid."
            ),
        ],
        tracking_id: Annotated[
            StrictStr, Field(description="tracking_id of the chunk you want to fetch")
        ],
        x_api_version: Annotated[
            Optional[Any],
            Field(
                description="The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ChunkReturnTypes:
        """Get Chunk By Tracking Id

        Get a singular chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use your own id as the primary reference for a chunk.

        :param tr_dataset: The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid. (required)
        :type tr_dataset: str
        :param tracking_id: tracking_id of the chunk you want to fetch (required)
        :type tracking_id: str
        :param x_api_version: The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
        :type x_api_version: APIVersion
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_chunk_by_tracking_id_serialize(
            tr_dataset=tr_dataset,
            tracking_id=tracking_id,
            x_api_version=x_api_version,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ChunkReturnTypes",
            "400": "ErrorResponseBody",
            "404": "ErrorResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _get_chunk_by_tracking_id_serialize(
        self,
        tr_dataset,
        tracking_id,
        x_api_version,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tracking_id is not None:
            _path_params["tracking_id"] = tracking_id
        # process the query parameters
        # process the header parameters
        if tr_dataset is not None:
            _header_params["TR-Dataset"] = tr_dataset
        if x_api_version is not None:
            _header_params["X-API-Version"] = x_api_version
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings: List[str] = ["ApiKey"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/chunk/tracking_id/{tracking_id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_chunks_by_ids(
        self,
        tr_dataset: Annotated[
            StrictStr,
            Field(
                description="The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid."
            ),
        ],
        get_chunks_data: Annotated[
            GetChunksData,
            Field(description="JSON request payload to get the chunks in the request"),
        ],
        x_api_version: Annotated[
            Optional[Any],
            Field(
                description="The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ChunkReturnTypes]:
        """Get Chunks By Ids

        Get multiple chunks by multiple ids.

        :param tr_dataset: The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid. (required)
        :type tr_dataset: str
        :param get_chunks_data: JSON request payload to get the chunks in the request (required)
        :type get_chunks_data: GetChunksData
        :param x_api_version: The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
        :type x_api_version: APIVersion
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_chunks_by_ids_serialize(
            tr_dataset=tr_dataset,
            get_chunks_data=get_chunks_data,
            x_api_version=x_api_version,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "List[ChunkReturnTypes]",
            "400": "ErrorResponseBody",
            "404": "ErrorResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _get_chunks_by_ids_serialize(
        self,
        tr_dataset,
        get_chunks_data,
        x_api_version,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if tr_dataset is not None:
            _header_params["TR-Dataset"] = tr_dataset
        if x_api_version is not None:
            _header_params["X-API-Version"] = x_api_version
        # process the form parameters
        # process the body parameter
        if get_chunks_data is not None:
            _body_params = get_chunks_data

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/json"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ["ApiKey"]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/api/chunks",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_chunks_by_tracking_ids(
        self,
        tr_dataset: Annotated[
            StrictStr,
            Field(
                description="The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid."
            ),
        ],
        get_tracking_chunks_data: Annotated[
            GetTrackingChunksData,
            Field(description="JSON request payload to get the chunks in the request"),
        ],
        x_api_version: Annotated[
            Optional[Any],
            Field(
                description="The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ChunkReturnTypes]:
        """Get Chunks By Tracking Ids

        Get multiple chunks by ids.

        :param tr_dataset: The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid. (required)
        :type tr_dataset: str
        :param get_tracking_chunks_data: JSON request payload to get the chunks in the request (required)
        :type get_tracking_chunks_data: GetTrackingChunksData
        :param x_api_version: The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
        :type x_api_version: APIVersion
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_chunks_by_tracking_ids_serialize(
            tr_dataset=tr_dataset,
            get_tracking_chunks_data=get_tracking_chunks_data,
            x_api_version=x_api_version,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "List[ChunkReturnTypes]",
            "400": "ErrorResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _get_chunks_by_tracking_ids_serialize(
        self,
        tr_dataset,
        get_tracking_chunks_data,
        x_api_version,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if tr_dataset is not None:
            _header_params["TR-Dataset"] = tr_dataset
        if x_api_version is not None:
            _header_params["X-API-Version"] = x_api_version
        # process the form parameters
        # process the body parameter
        if get_tracking_chunks_data is not None:
            _body_params = get_tracking_chunks_data

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/json"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ["ApiKey"]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/api/chunks/tracking",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_recommended_chunks(
        self,
        tr_dataset: Annotated[
            StrictStr,
            Field(
                description="The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid."
            ),
        ],
        recommend_chunks_request: Annotated[
            RecommendChunksRequest,
            Field(
                description="JSON request payload to get recommendations of chunks similar to the chunks in the request"
            ),
        ],
    ) -> RecommendResponseTypes:
        """Get Recommended Chunks

        Get recommendations of chunks similar to the positive samples in the request and dissimilar to the negative.

        :param tr_dataset: The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid. (required)
        :type tr_dataset: str
        :param recommend_chunks_request: JSON request payload to get recommendations of chunks similar to the chunks in the request (required)
        :type recommend_chunks_request: RecommendChunksRequest
        """  # noqa: E501

        payload = self.api_client.sanitize_for_serialization(recommend_chunks_request)

        url = self.api_client.configuration.host + "/api/chunk/recommend"
        headers = {
            "TR-Dataset": tr_dataset,
            "Authorization": self.api_client.configuration.api_key["ApiKey"],
            "Content-Type": "application/json",
            "X-API-Version": "V2",
        }

        response = requests.request("POST", url, json=payload, headers=headers)

        return response.json()

    @validate_call
    def get_suggested_queries(
        self,
        tr_dataset: Annotated[
            StrictStr,
            Field(
                description="The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid."
            ),
        ],
        suggested_queries_req_payload: Annotated[
            SuggestedQueriesReqPayload,
            Field(
                description="JSON request payload to get alternative suggested queries"
            ),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SuggestedQueriesResponse:
        """Generate suggested queries

        This endpoint will generate 3 suggested queries based off a hybrid search using RAG with the query provided in the request body and return them as a JSON object.

        :param tr_dataset: The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid. (required)
        :type tr_dataset: str
        :param suggested_queries_req_payload: JSON request payload to get alternative suggested queries (required)
        :type suggested_queries_req_payload: SuggestedQueriesReqPayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_suggested_queries_serialize(
            tr_dataset=tr_dataset,
            suggested_queries_req_payload=suggested_queries_req_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SuggestedQueriesResponse",
            "400": "ErrorResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _get_suggested_queries_serialize(
        self,
        tr_dataset,
        suggested_queries_req_payload,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if tr_dataset is not None:
            _header_params["TR-Dataset"] = tr_dataset
        # process the form parameters
        # process the body parameter
        if suggested_queries_req_payload is not None:
            _body_params = suggested_queries_req_payload

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/json"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ["ApiKey"]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/api/chunk/suggestions",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def scroll_dataset_chunks(
        self,
        tr_dataset: Annotated[
            StrictStr,
            Field(
                description="The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid."
            ),
        ],
        scroll_chunks_req_payload: Annotated[
            ScrollChunksReqPayload,
            Field(description="JSON request payload to scroll through chunks (chunks)"),
        ],
    ) -> ScrollChunksResponseBody:
        """Scroll Chunks

        Get paginated chunks from your dataset with filters and custom sorting. If sort by is not specified, the results will sort by the id's of the chunks in ascending order. Sort by and offset_chunk_id cannot be used together; if you want to scroll with a sort by then you need to use a must_not filter with the ids you have already seen. There is a limit of 1000 id's in a must_not filter at a time.

        :param tr_dataset: The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid. (required)
        :type tr_dataset: str
        :param scroll_chunks_req_payload: JSON request payload to scroll through chunks (chunks) (required)
        :type scroll_chunks_req_payload: ScrollChunksReqPayload
        """  # noqa: E501

        payload = self.api_client.sanitize_for_serialization(scroll_chunks_req_payload)

        url = self.api_client.configuration.host + "/api/chunks/scroll"
        headers = {
            "TR-Dataset": tr_dataset,
            "Authorization": self.api_client.configuration.api_key["ApiKey"],
            "Content-Type": "application/json",
            "X-API-Version": "V2",
        }

        response = requests.request("POST", url, json=payload, headers=headers)

        return response.json()

    def search_chunks(
        self,
        tr_dataset: Annotated[
            StrictStr,
            Field(
                description="The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid."
            ),
        ],
        search_chunks_req_payload: Annotated[
            ChunkReqPayload | List[ChunkReqPayload],
            Field(
                description="JSON request payload to semantically search for chunks (chunks)"
            ),
        ],
    ) -> SearchResponseTypes:
        """Search

        This route provides the primary search functionality for the API. It can be used to search for chunks by semantic similarity, full-text similarity, or a combination of both. Results' `chunk_html` values will be modified with `<mark><b>` or custom specified tags for sub-sentence highlighting.

        :param tr_dataset: The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid. (required)
        :type tr_dataset: str
        :param search_chunks_req_payload: JSON request payload to semantically search for chunks (chunks) (required)
        :type search_chunks_req_payload: SearchChunksReqPayload
        :param x_api_version: The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
        """  # noqa: E501
        payload = self.api_client.sanitize_for_serialization(search_chunks_req_payload)

        url = self.api_client.configuration.host + "/api/chunk/search"
        headers = {
            "TR-Dataset": tr_dataset,
            "Authorization": self.api_client.configuration.api_key["ApiKey"],
            "Content-Type": "application/json",
            "X-API-Version": "V2",
        }

        response = requests.request("POST", url, json=payload, headers=headers)

        return response.json()

    @validate_call
    def split_html_content(
        self,
        chunk_html_content_req_payload: Annotated[
            ChunkHtmlContentReqPayload,
            Field(
                description="JSON request payload to perform RAG on some chunks (chunks)"
            ),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SplitHtmlResponse:
        """Split HTML Content into Chunks

        This endpoint receives a single html string and splits it into chunks based on the headings and body content. The headings are split based on heading html tags. chunk_html has a maximum size of 256Kb.

        :param chunk_html_content_req_payload: JSON request payload to perform RAG on some chunks (chunks) (required)
        :type chunk_html_content_req_payload: ChunkHtmlContentReqPayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._split_html_content_serialize(
            chunk_html_content_req_payload=chunk_html_content_req_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SplitHtmlResponse",
            "413": "ErrorResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _split_html_content_serialize(
        self,
        chunk_html_content_req_payload,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if chunk_html_content_req_payload is not None:
            _body_params = chunk_html_content_req_payload

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/json"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/api/chunk/split",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def update_chunk(
        self,
        tr_dataset: Annotated[
            StrictStr,
            Field(
                description="The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid."
            ),
        ],
        update_chunk_req_payload: Annotated[
            UpdateChunkReqPayload,
            Field(description="JSON request payload to update a chunk (chunk)"),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Update Chunk

        Update a chunk. If you try to change the tracking_id of the chunk to have the same tracking_id as an existing chunk, the request will fail. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.

        :param tr_dataset: The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid. (required)
        :type tr_dataset: str
        :param update_chunk_req_payload: JSON request payload to update a chunk (chunk) (required)
        :type update_chunk_req_payload: UpdateChunkReqPayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_chunk_serialize(
            tr_dataset=tr_dataset,
            update_chunk_req_payload=update_chunk_req_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "204": None,
            "400": "ErrorResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _update_chunk_serialize(
        self,
        tr_dataset,
        update_chunk_req_payload,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if tr_dataset is not None:
            _header_params["TR-Dataset"] = tr_dataset
        # process the form parameters
        # process the body parameter
        if update_chunk_req_payload is not None:
            _body_params = update_chunk_req_payload

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/json"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ["ApiKey"]

        return self.api_client.param_serialize(
            method="PUT",
            resource_path="/api/chunk",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def update_chunk_by_tracking_id(
        self,
        tr_dataset: Annotated[
            StrictStr,
            Field(
                description="The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid."
            ),
        ],
        update_chunk_by_tracking_id_data: Annotated[
            UpdateChunkByTrackingIdData,
            Field(
                description="JSON request payload to update a chunk by tracking_id (chunks)"
            ),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """(Deprecated) Update Chunk By Tracking Id

        Update a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.

        :param tr_dataset: The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid. (required)
        :type tr_dataset: str
        :param update_chunk_by_tracking_id_data: JSON request payload to update a chunk by tracking_id (chunks) (required)
        :type update_chunk_by_tracking_id_data: UpdateChunkByTrackingIdData
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501
        warnings.warn(
            "PUT /api/chunk/tracking_id/update is deprecated.", DeprecationWarning
        )

        _param = self._update_chunk_by_tracking_id_serialize(
            tr_dataset=tr_dataset,
            update_chunk_by_tracking_id_data=update_chunk_by_tracking_id_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "204": None,
            "400": "ErrorResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _update_chunk_by_tracking_id_serialize(
        self,
        tr_dataset,
        update_chunk_by_tracking_id_data,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if tr_dataset is not None:
            _header_params["TR-Dataset"] = tr_dataset
        # process the form parameters
        # process the body parameter
        if update_chunk_by_tracking_id_data is not None:
            _body_params = update_chunk_by_tracking_id_data

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/json"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ["ApiKey"]

        return self.api_client.param_serialize(
            method="PUT",
            resource_path="/api/chunk/tracking_id/update",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )
